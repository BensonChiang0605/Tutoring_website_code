import cameralyze
import json
import requests
import os
import openai
import re
import base64
from requests.exceptions import RequestException, HTTPError, ConnectionError, Timeout
from dotenv import load_dotenv
load_dotenv()


def scan_image(file_content):
    headers = {
        "x-api-key": os.environ.get("x_api_key")
    }

    payload = {
        "itemUuid": "4eef90ef-00df-42a2-b152-69109a9a8602",
        "image": file_content_to_base64(file_content),
        "rawResponse": True,
        "configuration": {}
    }

    try:
        response = requests.post("https://inference.plugger.ai/", headers=headers, json=payload)
        response.raise_for_status()  # Raise an HTTPError for bad responses

        result = response.json()
        text_in_image = result["data"][0]["text"]
        return text_in_image

    except (RequestException, HTTPError, ConnectionError, Timeout) as e:
        print(f"An error occurred: {e}")
        print(f"Response content: {response.content if 'response' in locals() else None}")
        return None  # or handle the error in a way that makes sense for your application

    #response = requests.post("https://inference.plugger.ai/", headers=headers, json=payload)

    # result = response.json()
    # text_in_image = result["data"][0]["text"]
    # return text_in_image

def correct_grammar(scanned_texts, essay_question):
    openai.api_key = os.environ.get('open_api_key')


    response = openai.ChatCompletion.create(
        model="gpt-3.5-turbo-16k",
        messages=[
            {
                "role": "system",
                "content": f"You'll receive a text generated by an image-to-text app in response to the question '{essay_question}'. Your task is to correct any grammatical and logical errors while preserving the original meaning."
            },
            {
                "role": "user",
                "content": f"{scanned_texts}"
            },
        ],
        temperature=1,
        max_tokens=3500,
        top_p=1,
        frequency_penalty=0,
        presence_penalty=0
    )

    assistant_reply = response['choices'][0]['message']['content']
    return assistant_reply

def correct_spelling(scanned_texts, essay_question):
    openai.api_key = os.environ.get('open_api_key')

    response = openai.ChatCompletion.create(
        model="gpt-3.5-turbo-16k",
        messages=[
            {
                "role": "user",
                "content": f"I got this scanned text from an image to text application, please fix basic spelling errors\
                 and remove unnecessary line breaks but do not fix grammatical mistakes such as \n- Subject-Verb Agreement Errors \
                 \n- Misplaced or Dangling Modifiers \n- Wrong tense or verb form \n- Incorrect use of articles and prepositions\
                \nText: {scanned_texts}"
            },
        ],
        temperature=1,
        max_tokens=3500,
        top_p=1,
        frequency_penalty=0,
        presence_penalty=0
    )

    assistant_reply = response['choices'][0]['message']['content']
    return assistant_reply

def gpt_grammar_feedback(spell_checked_essay):
    openai.api_key = os.environ.get('open_api_key')

    response = openai.ChatCompletion.create(
        model="gpt-3.5-turbo-16k",
        messages=[
            {
                "role": "user",
                "content": "Identify grammar mistakes and poorly constructed sentences in this text.  First extract all sections where there is an issue, then summarise each issue you see, then make edits to improve the identified mistake, and finally explain your edits. Output your response in JSON.\n\nText: The circular flow diagram is a diagram that shows the relationship between households, firms, government, financial markets, and other countries in a market, how money flows in the system, and how government, financial markets, and other countries are involved in this closed system. The simple circular flow diagram only focused on the money flows between households and firms, which is a closed system. \nHowever, money will not always be in the system for households and firms. A portion of the money within the system will flow out to the government, financial markets, and other countries, which forms the complex circular flow diagram and shows how these injections and leakages work in the closed system. The government creates leakages through taxes, and injections through government spending. \nIn this case, households receive factor payments and dividends, including wages, profit, interest, and rent; meanwhile, they provide factors of production, which are land, labor, capital, and entrepreneurship, to firms. Furthermore, firms provide goods and services to households; at the same time, the expenditure on the goods and services will return to firms.\nFor the government, the leakage will be the taxes that are paid by households and firms four times a year, and this money will flow out of the system. For example, there are income taxes, sales taxes, etc. As a Taiwanese, Taiwanâ€™s income taxes increase from 5% to 12% to 20% to 30% to 40% while the income increases; moreover, the sale tax in Taiwan is 5%. \nBesides, the money that is added to the system, which is also known as the injection, will be government spending and transfers. Due to the circular flow diagram, these taxes will be used for government spending and transfers. For instance, the government will use this money to build or renew infrastructure, pay for health care and education for citizens, provide military funds, etc. According to data, the Taiwan government used 6.6% of the GDP for health care. These examples illustrate how the government provides injections and leakages to involve the circular flow diagram."
            },
            {
                "role": "assistant",
                "content": """{\n    \"problem_summaries\": [\n        \"Lack of parallelism in the list of items.\",\n        \"Lack of clarity and wordiness.\"\n    ],\n    \"original_sentences\": [\n        \"The circular flow diagram shows the relationship between households, firms, government, financial markets, and other countries in a market, how money flows in the system, and how government, financial markets, and other countries are involved in this closed system.\",\n        \"The simple circular flow diagram only focused on the money flows between households and firms, which is a closed system.\"\n    ],\n    \"revised_sentences\": [\n        \"The circular flow diagram illustrates the relationships among households, firms, government, financial markets, and other countries in a market, the flow of money in the system, and the involvement of government, financial markets, and other countries in this closed system.\",\n        \"The basic circular flow diagram solely focuses on the money exchange between households and firms, creating a closed system\"\n    ],\n    \"explanations\": [\n        \"I revised the sentence to maintain parallelism by listing all items in the same grammatical form.\",\n        \"I rephrased the sentence to make it clearer and more concise.\"\n}"""

            },
            {
                "role": "user",
                "content": f"Text:{spell_checked_essay}"
            }
        ],
        temperature=0.59,
        max_tokens=1297,
        top_p=1,
        frequency_penalty=0,
        presence_penalty=0
    )
    assistant_reply = response['choices'][0]['message']['content']
    return assistant_reply

def file_content_to_base64(file_content):
    return base64.b64encode(file_content).decode('utf-8')

def add_span_tags_to_text(text, sentences_to_tag):
    # Split the text into sentences using regular expressions
    sentences = re.split(r'(?<=[.!?])\s+', text)

    # Initialize a variable to store the result
    result = ""

    # Initialize a unique ID counter
    unique_id = 1

    for sentence in sentences:
        # Check if the current sentence is in the list
        if sentence in sentences_to_tag:
            # Add a <span> tag with a unique ID
            result += f'<span id="problem-{unique_id}">{sentence}</span> '
            unique_id += 1
        else:
            result += sentence + ' '

    return result.strip()
